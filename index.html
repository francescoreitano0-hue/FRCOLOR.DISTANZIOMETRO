
<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FR Color — Misurazione (Compatibile)</title>

  <style>
    :root{
      --bg: #F5F5F7;
      --surface: #FFFFFF;
      --text: #1D3557;
      --muted: rgba(29,53,87,.72);
      --border: rgba(29,53,87,.14);
      --shadow: 0 8px 24px rgba(29,53,87,.08);

      --primary: #1D3557;
      --ok: #26A69A;
      --ok-weak: rgba(38,166,154,.16);
      --warn: #FB8C00;
      --warn-weak: rgba(251,140,0,.16);
      --bad: #E53935;
      --bad-weak: rgba(229,57,53,.14);

      --radius: 16px;
      --radius-sm: 12px;
    }

    *{box-sizing:border-box}
    html, body{height:100%}
    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .wrap{max-width:980px; margin:0 auto; padding:14px;}

    .brandbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:14px; border:1px solid var(--border); border-radius:var(--radius);
      background:var(--surface); box-shadow:var(--shadow);
      flex-wrap:wrap;
    }
    .brandleft{display:flex; align-items:center; gap:12px; min-width:0;}
    .brandlogo{width:120px; max-width:38vw; height:auto; display:block;}
    .brandtitle{min-width:0}
    .brandtitle .title{margin:0; font-weight:800; letter-spacing:.2px; font-size:15px; line-height:1.1;}
    .brandtitle .sub{font-size:12px; color:var(--muted); margin-top:4px; line-height:1.35;}

    .status{
      font-size:12px; padding:7px 12px; border-radius:999px;
      border:1px solid var(--border); color:var(--muted); background:#fff; white-space:nowrap;
    }
    .status.ok{color:var(--ok); border-color:rgba(38,166,154,.35); background:var(--ok-weak);}
    .status.warn{color:var(--warn); border-color:rgba(251,140,0,.35); background:var(--warn-weak);}

    .grid{
      margin-top:12px;
      display:grid;
      gap:12px;
      grid-template-columns: 1.2fr .8fr;
    }
    @media (max-width: 900px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
      background:var(--surface);
      box-shadow:var(--shadow);
    }
    .card h3{
      margin:0;
      padding:12px 14px 10px;
      font-size:13px;
      font-weight:800;
      letter-spacing:.2px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, #ffffff, rgba(29,53,87,.02));
    }
    .card .body{padding:14px;}

    /* viewer desktop */
    .viewer{
      position:relative;
      width:100%;
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
      background:#0b0f14;
      aspect-ratio: 16/10;
    }
    video{width:100%; height:100%; object-fit:cover; display:block}
    canvas{position:absolute; inset:0; width:100%; height:100%; touch-action:none}

    /* viewer mobile 60vh */
    @media (max-width: 900px){
      .viewer{
        aspect-ratio:auto;
        height: min(60vh, 520px);
        min-height: 360px;
      }
      video, canvas{height:100%;}
    }

    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}

    .btn{
      appearance:none;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      padding:10px 12px;
      border-radius:var(--radius-sm);
      font-weight:800;
      cursor:pointer;
      transition: transform .04s ease, background .12s ease, border-color .12s ease;
    }
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:var(--primary); border-color:var(--primary); color:#fff;}
    .btn.primary:hover{background:#16304d}
    .btn:hover{background:rgba(29,53,87,.04)}
    .btn.small{padding:8px 10px; font-size:12px}
    .btn.danger{background:#fff; color:var(--bad); border-color:rgba(229,57,53,.35);}
    .btn.danger:hover{background:var(--bad-weak)}

    .select, .input{
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      padding:10px 12px;
      border-radius:var(--radius-sm);
      outline:none;
      min-width: 180px;
      font-weight:700;
    }
    .select:focus, .input:focus{
      border-color: rgba(30,136,229,.45);
      box-shadow: 0 0 0 4px rgba(30,136,229,.14);
    }

    .hint{color:var(--muted); font-size:12px; line-height:1.4; margin:8px 0 0;}
    .sep{height:1px; background:var(--border); margin:12px 0}

    .pill{
      font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid var(--border); color:var(--muted); background:#fff; font-weight:800;
    }
    .pill.ok{color:var(--ok); border-color:rgba(38,166,154,.35); background:var(--ok-weak);}
    .pill.bad{color:var(--bad); border-color:rgba(229,57,53,.35); background:var(--bad-weak);}

    .result{
      padding:12px; border:1px solid var(--border); border-radius:var(--radius-sm); background:#fff;
    }
    .result .label{font-size:12px; color:var(--muted); font-weight:800; letter-spacing:.15px;}
    .result strong{display:block; font-size:17px; margin-top:4px; letter-spacing:.2px;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}

    /* mirino */
    .crosshair{
      position:absolute;
      inset:0;
      pointer-events:none;
    }
    .crosshair::before, .crosshair::after{
      content:"";
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background: rgba(245,245,247,.92);
      border-radius: 999px;
      box-shadow: 0 0 0 2px rgba(11,15,20,.20);
    }
    .crosshair::before{ width: 34px; height: 2px; }
    .crosshair::after{ width: 2px; height: 34px; }

    /* fullscreen viewer */
    .viewer:fullscreen{width:100vw; height:100vh; border-radius:0; border:0;}
    .viewer:-webkit-full-screen{width:100vw; height:100vh; border-radius:0; border:0;}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="brandbar">
      <div class="brandleft">
        <!-- logo FR Color (opzionale qui: se src vuoto lo nascondo) -->
        <img class="brandlogo" id="brandLogo" src="" alt="FR Color — Logo ufficiale" />
        <div class="brandtitle">
          <p class="title">Misurazione (Modalità Compatibile)</p>
          <div class="sub">Fotocamera + calibrazione manuale. Modalità Distanza con “laser” live.</div>
        </div>
      </div>
      <div id="statusBadge" class="status warn">Calibrazione: NON attiva</div>
    </div>

    <div class="grid">
      <div class="card">
        <h3>Anteprima</h3>
        <div class="body">
          <div class="viewer" id="viewer">
            <video id="video" playsinline muted></video>
            <canvas id="overlay"></canvas>
            <div class="crosshair" aria-hidden="true"></div>
          </div>

          <div class="sep"></div>

          <div class="row">
            <button id="btnStartCam" class="btn primary">Avvia fotocamera</button>
            <button id="btnStopCam" class="btn">Ferma</button>
            <button id="btnFullscreen" class="btn">Schermo intero</button>
            <span id="modePill" class="pill">Modalità: —</span>
          </div>

          <p class="hint">
            Distanza: tap 1 = punto A, muovi e leggi la misura live, tap 2 = punto B (blocca).
          </p>
        </div>
      </div>

      <div class="card">
        <h3>Controlli</h3>
        <div class="body">

          <div class="row">
            <select id="mode" class="select">
              <option value="calibrate">Calibrazione</option>
              <option value="distance">Misura distanza (laser)</option>
              <option value="area">Misura area (rettangolo)</option>
            </select>

            <select id="refPreset" class="select">
              <option value="21">A4 lato corto (21 cm)</option>
              <option value="29.7">A4 lato lungo (29.7 cm)</option>
              <option value="8.56">Carta di credito (8.56 cm)</option>
              <option value="custom">Valore manuale…</option>
            </select>

            <input id="refCustom" class="input" type="number" step="0.1" min="0" placeholder="cm (manuale)" style="display:none" />
          </div>

          <div class="sep"></div>

          <div class="row">
            <button id="btnRecalibrate" class="btn small">Rifai calibrazione</button>
            <button id="btnReset" class="btn small danger">Reset calibrazione</button>
            <button id="btnClearMeasure" class="btn small">Azzera misura</button>
          </div>

          <div class="sep"></div>

          <div class="result">
            <div class="label">Risultato</div>
            <strong id="resultMain">—</strong>
            <div class="hint mono" id="resultDetails">—</div>
          </div>

          <div class="sep"></div>

          <p class="hint">
            Area: 2 tap larghezza + 2 tap altezza (come prima). Distanza: “laser” live tra punto A e mirino.
          </p>
        </div>
      </div>
    </div>
  </div>

<script>
const FRColorMeasureModule = (() => {
  const LS_KEY = "frcolor_measure_calibration_v1";

  let video, canvas, ctx, viewer;
  let stream = null;

  // state
  let mode = "calibrate"; // calibrate | distance | area
  let taps = [];          // usato per area + calibrazione
  let cmPerPx = null;
  let calibrationMeta = null;

  // distanza laser
  let anchorA = null;     // punto A fissato con tap1 (in coordinate CSS)
  let lockedB = null;     // punto B bloccato con tap2 (in coordinate CSS)
  let rafId = null;

  // UI
  let elStatusBadge, elMode, elModePill, elRefPreset, elRefCustom;
  let elResultMain, elResultDetails;

  function nowISO(){ return new Date().toISOString(); }

  function loadCalibration() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (typeof obj?.cmPerPx === "number" && obj.cmPerPx > 0) {
        cmPerPx = obj.cmPerPx;
        calibrationMeta = obj.meta || null;
      }
    } catch {}
  }

  function saveCalibration() {
    const payload = {
      cmPerPx,
      meta: {
        savedAt: nowISO(),
        videoSettings: stream?.getVideoTracks?.()?.[0]?.getSettings?.() || null,
        userAgent: navigator.userAgent
      }
    };
    localStorage.setItem(LS_KEY, JSON.stringify(payload));
    calibrationMeta = payload.meta;
  }

  function clearCalibration() {
    localStorage.removeItem(LS_KEY);
    cmPerPx = null;
    calibrationMeta = null;
  }

  function setStatus() {
    if (!elStatusBadge) return;
    if (cmPerPx) {
      elStatusBadge.className = "status ok";
      const when = calibrationMeta?.savedAt ? calibrationMeta.savedAt.split("T")[0] : "—";
      elStatusBadge.textContent = `Calibrazione: attiva (${when})`;
    } else {
      elStatusBadge.className = "status warn";
      elStatusBadge.textContent = "Calibrazione: NON attiva";
    }
  }

  function updateModePill() {
    const label = mode === "calibrate" ? "Calibrazione"
      : (mode === "distance" ? "Distanza" : "Area");
    elModePill.textContent = `Modalità: ${label}`;
    elModePill.className = "pill " + (cmPerPx ? "ok" : "bad");
  }

  function setResult(main, details) {
    elResultMain.textContent = main;
    elResultDetails.textContent = details || "";
  }

  function resetTaps() {
    taps = [];
    redraw();
  }

  function clearLaserMeasure() {
    anchorA = null;
    lockedB = null;
    stopLiveLoop();
    redraw();
    setResult("—", "—");
  }

  function setMode(newMode) {
    mode = newMode;
    resetTaps();
    clearLaserMeasure();
    updateModePill();
    if (mode === "calibrate") setResult("—", "Calibrazione: 2 tap sul riferimento.");
    if (mode === "distance") setResult("—", "Distanza: tap A, muovi (live), tap B per bloccare.");
    if (mode === "area") setResult("—", "Area: 2 tap larghezza + 2 tap altezza.");
  }

  async function startCamera() {
    if (!navigator.mediaDevices?.getUserMedia) {
      setResult("Errore", "Browser non supporta getUserMedia.");
      return;
    }
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: "environment" } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      resizeCanvasToDisplay();
      redraw();
      setResult("Camera OK", "Seleziona modalità e inizia.");
    } catch (e) {
      setResult("Camera non avviata", `${e.name || "Errore"}: ${e.message || ""}`.trim());
    }
  }

  function stopCamera() {
    try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch {}
    stream = null;
    video.srcObject = null;
    stopLiveLoop();
    setResult("Camera fermata", "—");
  }

  function enterFullscreen() {
    const el = viewer;
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
    if (req) req.call(el);
  }

  function getReferenceCm() {
    const preset = elRefPreset.value;
    if (preset === "custom") {
      const v = parseFloat(elRefCustom.value);
      return (Number.isFinite(v) && v > 0) ? v : null;
    }
    const n = parseFloat(preset);
    return (Number.isFinite(n) && n > 0) ? n : null;
  }

  function resizeCanvasToDisplay() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.round(rect.width * dpr));
    canvas.height = Math.max(1, Math.round(rect.height * dpr));
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }

  function canvasPointFromEvent(evt) {
    const rect = canvas.getBoundingClientRect();
    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
  }

  function getCrosshairPoint() {
    // punto B live = centro del canvas in coordinate CSS
    const rect = canvas.getBoundingClientRect();
    return { x: rect.width / 2, y: rect.height / 2 };
  }

  function distPx(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function formatDistance(cm) {
    if (cm >= 100) return (cm/100).toFixed(2) + " m";
    return cm.toFixed(1) + " cm";
  }

  function formatAreaMq(cm2) {
    const mq = cm2 / 10000;
    return mq.toFixed(2) + " m²";
  }

  function stopLiveLoop() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }

  function startLiveLoop() {
    stopLiveLoop();
    const loop = () => {
      if (mode !== "distance" || !anchorA || !cmPerPx || lockedB) {
        rafId = null;
        return;
      }
      const liveB = getCrosshairPoint();
      const cm = distPx(anchorA, liveB) * cmPerPx;
      // misura live vicino alla linea: render in redraw + testo qui
      setResult("Distanza (live)", `${formatDistance(cm)} (indicativa)`);
      redraw(liveB, cm);
      rafId = requestAnimationFrame(loop);
    };
    rafId = requestAnimationFrame(loop);
  }

  function handleTap(pt) {
    if (!stream) {
      setResult("Avvia la fotocamera", "Prima avvia la fotocamera.");
      return;
    }

    // CALIBRAZIONE
    if (mode === "calibrate") {
      taps.push(pt);

      if (taps.length === 1) {
        setResult("Calibrazione", "Tocca il secondo punto.");
        redraw();
        return;
      }
      if (taps.length === 2) {
        const refCm = getReferenceCm();
        if (!refCm) {
          resetTaps();
          setResult("Calibrazione", "Valore cm non valido.");
          return;
        }
        const px = distPx(taps[0], taps[1]);
        if (!(px > 0)) {
          resetTaps();
          setResult("Calibrazione", "Distanza non valida.");
          return;
        }
        cmPerPx = refCm / px;
        saveCalibration();
        setStatus();
        updateModePill();
        setResult("Calibrato ✅", `Rapporto: ${cmPerPx.toExponential(3)} cm/px`);
        resetTaps();
        return;
      }
      resetTaps();
      return;
    }

    // per misure serve calibrazione
    if (!cmPerPx) {
      setResult("Calibrazione richiesta", "Passa a Calibrazione e calibra prima.");
      return;
    }

    // DISTANZA LASER (tap A / tap B)
    if (mode === "distance") {
      if (!anchorA) {
        anchorA = pt;     // tap 1 = A
        lockedB = null;
        setResult("Distanza (live)", "—");
        startLiveLoop();
        redraw();
        return;
      }

      if (anchorA && !lockedB) {
        // tap 2 = blocca B dove stai mirando (crosshair)
        lockedB = getCrosshairPoint();
        stopLiveLoop();

        const cm = distPx(anchorA, lockedB) * cmPerPx;
        setResult("Distanza", `${formatDistance(cm)} (indicativa)`);
        redraw(null, cm); // disegna laser bloccato
        return;
      }

      // tap successivo: riparti
      anchorA = pt;
      lockedB = null;
      setResult("Distanza (live)", "—");
      startLiveLoop();
      redraw();
      return;
    }

    // AREA (come prima)
    if (mode === "area") {
      taps.push(pt);

      if (taps.length === 1) {
        setResult("Area", "Tocca il secondo punto per la larghezza.");
        redraw();
        return;
      }
      if (taps.length === 2) {
        const cmW = distPx(taps[0], taps[1]) * cmPerPx;
        setResult("Area", `Larghezza: ${formatDistance(cmW)} — Ora 2 tap per altezza.`);
        redraw();
        return;
      }
      if (taps.length === 3) {
        setResult("Area", "Tocca il secondo punto per l’altezza.");
        redraw();
        return;
      }
      if (taps.length === 4) {
        const cmW = distPx(taps[0], taps[1]) * cmPerPx;
        const cmH = distPx(taps[2], taps[3]) * cmPerPx;
        setResult("Area (rettangolo)", `${formatAreaMq(cmW * cmH)} (indicativa)`);
        resetTaps();
        return;
      }

      resetTaps();
      return;
    }
  }

  function drawLabelOnLine(a, b, text) {
    // posizione a metà linea, leggermente offset
    const midX = (a.x + b.x) / 2;
    const midY = (a.y + b.y) / 2;

    ctx.save();
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(245,245,247,.95)";
    ctx.strokeStyle = "rgba(11,15,20,.35)";
    ctx.lineWidth = 4;

    const padX = 8, padY = 6;
    const w = ctx.measureText(text).width;
    const x = midX + 10;
    const y = midY - 10;

    // “etichetta” semplice
    ctx.strokeText(text, x, y);
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  function redraw(liveBOverride=null, liveCm=null) {
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0, 0, rect.width, rect.height);

    // overlay tecnico pulito
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(245,245,247,.95)";
    ctx.fillStyle = "rgba(245,245,247,.95)";

    // CALIBRAZIONE/AREA: disegna linee tap
    if (mode === "calibrate" || mode === "area") {
      if (taps.length >= 2) {
        ctx.beginPath();
        ctx.moveTo(taps[0].x, taps[0].y);
        ctx.lineTo(taps[1].x, taps[1].y);
        ctx.stroke();
      }
      if (mode === "area" && taps.length >= 4) {
        ctx.beginPath();
        ctx.moveTo(taps[2].x, taps[2].y);
        ctx.lineTo(taps[3].x, taps[3].y);
        ctx.stroke();
      }

      taps.forEach((p, i) => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
        ctx.fillText(String(i + 1), p.x + 10, p.y - 10);
      });
      return;
    }

    // DISTANZA LASER
    if (mode === "distance" && anchorA) {
      const b = lockedB || liveBOverride || getCrosshairPoint();

      // linea “laser” tratteggiata
      ctx.save();
      ctx.setLineDash([10, 8]);
      ctx.beginPath();
      ctx.moveTo(anchorA.x, anchorA.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
      ctx.restore();

      // punto A
      ctx.beginPath();
      ctx.arc(anchorA.x, anchorA.y, 6, 0, Math.PI * 2);
      ctx.fill();

      // etichetta misura vicino alla linea
      if (cmPerPx) {
        const cm = (typeof liveCm === "number" && !lockedB) ? liveCm : (distPx(anchorA, b) * cmPerPx);
        drawLabelOnLine(anchorA, b, formatDistance(cm));
      }
    }
  }

  function wireUI() {
    document.getElementById("btnStartCam").addEventListener("click", startCamera);
    document.getElementById("btnStopCam").addEventListener("click", stopCamera);
    document.getElementById("btnFullscreen").addEventListener("click", enterFullscreen);

    elMode.addEventListener("change", () => setMode(elMode.value));

    elRefPreset.addEventListener("change", () => {
      elRefCustom.style.display = (elRefPreset.value === "custom") ? "inline-block" : "none";
    });

    document.getElementById("btnRecalibrate").addEventListener("click", () => {
      elMode.value = "calibrate";
      setMode("calibrate");
    });

    document.getElementById("btnReset").addEventListener("click", () => {
      clearCalibration();
      setStatus();
      updateModePill();
      clearLaserMeasure();
      resetTaps();
      setResult("Reset", "Calibrazione cancellata.");
    });

    document.getElementById("btnClearMeasure").addEventListener("click", () => {
      clearLaserMeasure();
    });

    // pointerup più stabile su Android
    canvas.addEventListener("pointerup", (evt) => {
      evt.preventDefault();
      handleTap(canvasPointFromEvent(evt));
      redraw();
    });

    window.addEventListener("resize", () => {
      resizeCanvasToDisplay();
      redraw();
    });

    document.addEventListener("fullscreenchange", () => {
      resizeCanvasToDisplay();
      redraw();
    });
  }

  function init() {
    video = document.getElementById("video");
    canvas = document.getElementById("overlay");
    ctx = canvas.getContext("2d");
    viewer = document.getElementById("viewer");

    elStatusBadge = document.getElementById("statusBadge");
    elMode = document.getElementById("mode");
    elModePill = document.getElementById("modePill");
    elRefPreset = document.getElementById("refPreset");
    elRefCustom = document.getElementById("refCustom");
    elResultMain = document.getElementById("resultMain");
    elResultDetails = document.getElementById("resultDetails");

    loadCalibration();
    setStatus();

    setMode("distance");
    elMode.value = "distance";
    updateModePill();

    requestAnimationFrame(() => {
      resizeCanvasToDisplay();
      redraw();
    });

    wireUI();

    // se logo non impostato, non rompe nulla
    const logo = document.getElementById("brandLogo");
    if (logo && !logo.getAttribute("src")) {
      logo.style.display = "none";
    }
  }

  return { init };
})();

document.addEventListener("DOMContentLoaded", () => {
  FRColorMeasureModule.init();
});
</script>
</body>
</html>
