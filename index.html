
<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FR Color — Misure (Compatibile)</title>

  <style>
    :root{
      --bg: #F5F5F7;
      --surface: #FFFFFF;
      --text: #1D3557;
      --muted: rgba(29,53,87,.72);
      --border: rgba(29,53,87,.14);
      --shadow: 0 8px 24px rgba(29,53,87,.08);

      --primary: #1D3557;
      --ok: #26A69A;
      --ok-weak: rgba(38,166,154,.16);
      --warn: #FB8C00;
      --warn-weak: rgba(251,140,0,.16);
      --bad: #E53935;
      --bad-weak: rgba(229,57,53,.14);

      --radius: 16px;
      --radius-sm: 12px;
    }

    *{box-sizing:border-box}
    html, body{height:100%}
    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .wrap{max-width:980px; margin:0 auto; padding:14px;}

    .brandbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:14px; border:1px solid var(--border); border-radius:var(--radius);
      background:var(--surface); box-shadow:var(--shadow);
      flex-wrap:wrap;
    }
    .brandleft{display:flex; align-items:center; gap:12px; min-width:0;}
    .brandlogo{width:120px; max-width:38vw; height:auto; display:block;}
    .brandtitle{min-width:0}
    .brandtitle .title{margin:0; font-weight:800; letter-spacing:.2px; font-size:15px; line-height:1.1;}
    .brandtitle .sub{font-size:12px; color:var(--muted); margin-top:4px; line-height:1.35;}

    .status{
      font-size:12px; padding:7px 12px; border-radius:999px;
      border:1px solid var(--border); color:var(--muted); background:#fff; white-space:nowrap;
    }
    .status.ok{color:var(--ok); border-color:rgba(38,166,154,.35); background:var(--ok-weak);}
    .status.warn{color:var(--warn); border-color:rgba(251,140,0,.35); background:var(--warn-weak);}

    .grid{
      margin-top:12px;
      display:grid;
      gap:12px;
      grid-template-columns: 1.2fr .8fr;
    }
    @media (max-width: 900px){ .grid{grid-template-columns:1fr} }

    .card{
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
      background:var(--surface);
      box-shadow:var(--shadow);
    }
    .card h3{
      margin:0;
      padding:12px 14px 10px;
      font-size:13px;
      font-weight:800;
      letter-spacing:.2px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, #ffffff, rgba(29,53,87,.02));
    }
    .card .body{padding:14px;}

    /* viewer desktop */
    .viewer{
      position:relative;
      width:100%;
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
      background:#0b0f14;
      aspect-ratio: 16/10;
    }
    video{width:100%; height:100%; object-fit:cover; display:block}
    canvas{position:absolute; inset:0; width:100%; height:100%; touch-action:none}

    /* viewer mobile 60vh */
    @media (max-width: 900px){
      .viewer{
        aspect-ratio:auto;
        height: min(60vh, 520px);
        min-height: 360px;
      }
      video, canvas{height:100%;}
    }

    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .btn{
      appearance:none;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      padding:10px 12px;
      border-radius:var(--radius-sm);
      font-weight:800;
      cursor:pointer;
      transition: transform .04s ease, background .12s ease, border-color .12s ease, opacity .12s ease;
    }
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:var(--primary); border-color:var(--primary); color:#fff;}
    .btn.primary:hover{background:#16304d}
    .btn:hover{background:rgba(29,53,87,.04)}
    .btn.small{padding:8px 10px; font-size:12px}
    .btn.danger{background:#fff; color:var(--bad); border-color:rgba(229,57,53,.35);}
    .btn.danger:hover{background:var(--bad-weak)}
    .btn:disabled{opacity:.45; cursor:not-allowed}
    .select, .input{
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      padding:10px 12px;
      border-radius:var(--radius-sm);
      outline:none;
      min-width: 180px;
      font-weight:700;
      transition: opacity .12s ease;
    }
    .select:focus, .input:focus{
      border-color: rgba(30,136,229,.45);
      box-shadow: 0 0 0 4px rgba(30,136,229,.14);
    }
    .select:disabled, .input:disabled{opacity:.45; cursor:not-allowed}

    .hint{color:var(--muted); font-size:12px; line-height:1.4; margin:8px 0 0;}
    .sep{height:1px; background:var(--border); margin:12px 0}

    .pill{
      font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid var(--border); color:var(--muted); background:#fff; font-weight:800;
    }
    .pill.ok{color:var(--ok); border-color:rgba(38,166,154,.35); background:var(--ok-weak);}
    .pill.bad{color:var(--bad); border-color:rgba(229,57,53,.35); background:var(--bad-weak);}

    .result{
      padding:12px; border:1px solid var(--border); border-radius:var(--radius-sm); background:#fff;
    }
    .result .label{font-size:12px; color:var(--muted); font-weight:800; letter-spacing:.15px;}
    .result strong{display:block; font-size:17px; margin-top:4px; letter-spacing:.2px;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}

    /* mirino (opzionale) */
    .crosshair{
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity: 0;
      transition: opacity .12s ease;
    }
    .crosshair.on{opacity:1;}
    .crosshair::before, .crosshair::after{
      content:"";
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background: rgba(245,245,247,.92);
      border-radius: 999px;
      box-shadow: 0 0 0 2px rgba(11,15,20,.20);
    }
    .crosshair::before{ width: 34px; height: 2px; }
    .crosshair::after{ width: 2px; height: 34px; }

    /* fullscreen */
    .viewer:fullscreen{width:100vw; height:100vh; border-radius:0; border:0;}
    .viewer:-webkit-full-screen{width:100vw; height:100vh; border-radius:0; border:0;}

    /* accordion */
    details{
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: #fff;
      padding: 10px 12px;
    }
    details + details{margin-top:10px}
    summary{
      cursor:pointer;
      list-style:none;
      font-weight: 900;
      letter-spacing:.15px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
    }
    summary::-webkit-details-marker{display:none}
    .sum-right{display:flex; align-items:center; gap:8px}
    .tag{
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      background:#fff;
      font-weight:800;
      white-space:nowrap;
    }
    .tag.ok{color:var(--ok); border-color:rgba(38,166,154,.35); background:var(--ok-weak);}
    .tag.bad{color:var(--bad); border-color:rgba(229,57,53,.35); background:var(--bad-weak);}

    /* storico misure */
    .history{
      border:1px solid var(--border);
      border-radius: var(--radius-sm);
      padding:10px 12px;
      background:#fff;
    }
    .history-head{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom:8px;
    }
    .history-list{
      margin:0;
      padding-left: 18px;
      color: var(--text);
      font-weight: 800;
    }
    .history-list li{
      margin: 6px 0;
      font-weight: 800;
    }
    .history-meta{
      font-size:12px; color:var(--muted);
      font-weight:800;
    }

    /* zoom badge */
    .zoom-badge{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      background:#fff;
      font-weight:900;
      white-space:nowrap;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="brandbar">
      <div class="brandleft">
        <img class="brandlogo" id="brandLogo" src="" alt="FR Color — Logo ufficiale" />
        <div class="brandtitle">
          <p class="title">Misure Cantiere (Compatibile)</p>
          <div class="sub">Distanza (dito/mirino) + Area. Zoom preferito 0.6 (se supportato).</div>
        </div>
      </div>
      <div class="row" style="gap:8px;">
        <div id="zoomBadge" class="zoom-badge">Zoom: —</div>
        <div id="statusBadge" class="status warn">Calibrazione: NON attiva</div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h3>Schermo Misurazione</h3>
        <div class="body">
          <div class="viewer" id="viewer">
            <video id="video" playsinline muted></video>
            <canvas id="overlay"></canvas>
            <div id="crosshair" class="crosshair" aria-hidden="true"></div>
          </div>

          <div class="sep"></div>

          <div class="row">
            <button id="btnStartCam" class="btn primary">Avvia fotocamera</button>
            <button id="btnStopCam" class="btn">Ferma</button>
            <button id="btnFullscreen" class="btn">Schermo intero</button>
            <span id="modePill" class="pill">Modalità: —</span>
          </div>

          <p class="hint">
            Distanza: tap A → trascina col dito per B (live) → tap finale blocca e salva.
          </p>
        </div>
      </div>

      <div class="card">
        <h3>Controlli</h3>
        <div class="body">

          <!-- CALIBRAZIONE (accordion) -->
          <details id="calPanel" open>
            <summary>
              <span>Calibrazione</span>
              <span class="sum-right">
                <span id="calTag" class="tag bad">NON attiva</span>
              </span>
            </summary>

            <div class="sep"></div>

            <div class="row">
              <select id="refPreset" class="select">
                <option value="21">A4 lato corto (21 cm)</option>
                <option value="29.7">A4 lato lungo (29.7 cm)</option>
                <option value="8.56">Carta di credito (8.56 cm)</option>
                <option value="custom">Valore manuale…</option>
              </select>

              <input id="refCustom" class="input" type="number" step="0.1" min="0" placeholder="cm (manuale)" style="display:none" />
            </div>

            <div class="sep"></div>

            <div class="row">
              <button id="btnModeCal" class="btn small primary">Modalità calibrazione</button>
              <button id="btnResetCal" class="btn small danger">Reset calibrazione</button>
            </div>
          </details>

          <!-- MISURE CANTIERE (accordion) -->
          <details id="msrPanel" open>
            <summary>
              <span>Misure cantiere</span>
              <span class="sum-right">
                <span id="msrTag" class="tag">PRONTO</span>
              </span>
            </summary>

            <div class="sep"></div>

            <div class="row">
              <select id="mode" class="select">
                <option value="distance">Distanza</option>
                <option value="area">Area (rettangolo)</option>
              </select>

              <select id="targetMode" class="select">
                <option value="finger" selected>Puntamento B: Dito</option>
                <option value="crosshair">Puntamento B: Mirino</option>
              </select>
            </div>

            <div class="sep"></div>

            <div class="row">
              <button id="btnClearMeasure" class="btn small">Azzera misura</button>
              <button id="btnClearHistory" class="btn small danger">Azzera storico</button>
            </div>

            <div class="sep"></div>

            <div class="history">
              <div class="history-head">
                <div class="history-meta" id="historyMeta">Storico misure: 0/10</div>
                <div class="history-meta">Reset automatico alla 11ª</div>
              </div>
              <ol class="history-list" id="historyList"></ol>
            </div>
          </details>

          <div class="sep"></div>

          <div class="result">
            <div class="label">Risultato</div>
            <strong id="resultMain">—</strong>
            <div class="hint mono" id="resultDetails">—</div>
          </div>

        </div>
      </div>
    </div>
  </div>

<script>
const FRColorMeasureModule = (() => {
  const LS_KEY = "frcolor_measure_calibration_v1";

  let video, canvas, ctx, viewer, crosshairEl;
  let stream = null;
  let videoTrack = null;

  // modes
  let appMode = "measure";      // "calibrate" | "measure"
  let measureMode = "distance"; // "distance" | "area"
  let targetMode = "finger";    // "finger" | "crosshair"

  // calibration
  let cmPerPx = null;
  let calibrationMeta = null;
  let calTaps = [];

  // distance (laser)
  let anchorA = null;
  let liveB = null;
  let lockedB = null;
  let isDragging = false;

  // area
  let areaTaps = [];

  // history
  let history = [];

  // UI
  let elStatusBadge, elZoomBadge, elModePill;
  let elResultMain, elResultDetails;

  let elCalPanel, elMsrPanel, elCalTag, elMsrTag;
  let elRefPreset, elRefCustom;
  let elMeasureMode, elTargetMode;
  let elHistoryList, elHistoryMeta;

  function nowISO(){ return new Date().toISOString(); }

  function loadCalibration() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (typeof obj?.cmPerPx === "number" && obj.cmPerPx > 0) {
        cmPerPx = obj.cmPerPx;
        calibrationMeta = obj.meta || null;
      }
    } catch {}
  }

  function saveCalibration() {
    const payload = {
      cmPerPx,
      meta: {
        savedAt: nowISO(),
        videoSettings: videoTrack?.getSettings?.() || null,
        userAgent: navigator.userAgent
      }
    };
    localStorage.setItem(LS_KEY, JSON.stringify(payload));
    calibrationMeta = payload.meta;
  }

  function clearCalibration() {
    localStorage.removeItem(LS_KEY);
    cmPerPx = null;
    calibrationMeta = null;
  }

  function setStatus() {
    if (cmPerPx) {
      elStatusBadge.className = "status ok";
      const when = calibrationMeta?.savedAt ? calibrationMeta.savedAt.split("T")[0] : "—";
      elStatusBadge.textContent = `Calibrazione: attiva (${when})`;

      elCalTag.className = "tag ok";
      elCalTag.textContent = "ATTIVA";
    } else {
      elStatusBadge.className = "status warn";
      elStatusBadge.textContent = "Calibrazione: NON attiva";

      elCalTag.className = "tag bad";
      elCalTag.textContent = "NON attiva";
    }
  }

  function setModePill() {
    const label = (appMode === "calibrate")
      ? "Calibrazione"
      : (measureMode === "distance" ? "Distanza" : "Area");
    elModePill.textContent = `Modalità: ${label}`;
    elModePill.className = "pill " + (cmPerPx ? "ok" : "bad");
  }

  function setResult(main, details) {
    elResultMain.textContent = main;
    elResultDetails.textContent = details || "—";
  }

  function resizeCanvasToDisplay() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.round(rect.width * dpr));
    canvas.height = Math.max(1, Math.round(rect.height * dpr));
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }

  function canvasPointFromEvent(evt) {
    const rect = canvas.getBoundingClientRect();
    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
  }

  function getCrosshairPoint() {
    const rect = canvas.getBoundingClientRect();
    return { x: rect.width / 2, y: rect.height / 2 };
  }

  function distPx(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function formatDistance(cm) {
    if (cm >= 100) return (cm/100).toFixed(2) + " m";
    return cm.toFixed(1) + " cm";
  }

  function formatAreaMq(cm2) {
    const mq = cm2 / 10000;
    return mq.toFixed(2) + " m²";
  }

  function getReferenceCm() {
    const preset = elRefPreset.value;
    if (preset === "custom") {
      const v = parseFloat(elRefCustom.value);
      return (Number.isFinite(v) && v > 0) ? v : null;
    }
    const n = parseFloat(preset);
    return (Number.isFinite(n) && n > 0) ? n : null;
  }

  function setCrosshairVisible(on) {
    if (on) crosshairEl.classList.add("on");
    else crosshairEl.classList.remove("on");
  }

  function updatePanelsState() {
    const inCal = (appMode === "calibrate");

    if (!inCal) elCalPanel.open = false;
    else elCalPanel.open = true;

    const calDisabled = !inCal;
    elRefPreset.disabled = calDisabled;
    elRefCustom.disabled = calDisabled;
    document.getElementById("btnResetCal").disabled = calDisabled;

    elMsrTag.className = "tag";
    elMsrTag.textContent = "PRONTO";

    setCrosshairVisible(appMode === "measure" && measureMode === "distance" && targetMode === "crosshair");
  }

  function enterCalibrationMode() {
    appMode = "calibrate";
    clearMeasureState();
    calTaps = [];
    areaTaps = [];
    setResult("Calibrazione", "2 tap sul riferimento");
    setModePill();
    updatePanelsState();
    redraw();
  }

  function enterMeasureMode() {
    appMode = "measure";
    calTaps = [];
    setModePill();
    updatePanelsState();
    redraw();
  }

  function clearMeasureState() {
    anchorA = null;
    liveB = null;
    lockedB = null;
    isDragging = false;
    areaTaps = [];
  }

  function updateHistoryUI() {
    elHistoryList.innerHTML = "";
    history.forEach((h) => {
      const li = document.createElement("li");
      li.textContent = h.valueText;
      elHistoryList.appendChild(li);
    });
    elHistoryMeta.textContent = `Storico misure: ${history.length}/10`;
  }

  function addToHistory(valueText) {
    if (history.length === 10) history = [];
    history.push({ valueText });
    updateHistoryUI();
  }

  function updateZoomBadge() {
    const z = videoTrack?.getSettings?.()?.zoom;
    if (z == null) elZoomBadge.textContent = "Zoom: —";
    else elZoomBadge.textContent = `Zoom: ${Number(z).toFixed(2)}`;
  }

  async function applyPreferredZoom(track, preferredZoom = 0.6) {
    try {
      const caps = track.getCapabilities?.();
      if (!caps || !caps.zoom) return { applied:false, reason:"zoom not supported" };

      const minZ = caps.zoom.min;
      const maxZ = caps.zoom.max;

      let target = preferredZoom;
      if (typeof minZ === "number" && typeof maxZ === "number") {
        if (target < minZ) target = minZ;
        if (target > maxZ) target = maxZ;
      }

      await track.applyConstraints({ advanced: [{ zoom: target }] });
      return { applied:true, used: track.getSettings?.()?.zoom ?? target };
    } catch (e) {
      // fallback: try min zoom
      try {
        const caps = track.getCapabilities?.();
        if (caps?.zoom?.min != null) {
          await track.applyConstraints({ advanced: [{ zoom: caps.zoom.min }] });
          return { applied:true, used: track.getSettings?.()?.zoom ?? caps.zoom.min, fallback:true };
        }
      } catch {}
      return { applied:false, reason: e?.name || "applyConstraints failed" };
    }
  }

  async function startCamera() {
    if (!navigator.mediaDevices?.getUserMedia) {
      setResult("Errore", "Browser non supporta getUserMedia.");
      return;
    }
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: "environment" } },
        audio: false
      });

      videoTrack = stream.getVideoTracks()[0] || null;

      // prefer zoom 0.6 (se supportato), altrimenti zoom minimo
      if (videoTrack) await applyPreferredZoom(videoTrack, 0.6);

      video.srcObject = stream;
      await video.play();

      resizeCanvasToDisplay();
      redraw();

      updateZoomBadge();
      setResult("Camera OK", "—");
    } catch (e) {
      setResult("Camera non avviata", `${e.name || "Errore"}: ${e.message || ""}`.trim());
    }
  }

  function stopCamera() {
    try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch {}
    stream = null;
    videoTrack = null;
    video.srcObject = null;
    updateZoomBadge();
    setResult("Camera fermata", "—");
    redraw();
  }

  function enterFullscreen() {
    const req = viewer.requestFullscreen || viewer.webkitRequestFullscreen || viewer.msRequestFullscreen;
    if (req) req.call(viewer);
  }

  function drawLabelOnLine(a, b, text) {
    const midX = (a.x + b.x) / 2;
    const midY = (a.y + b.y) / 2;
    ctx.save();
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(245,245,247,.95)";
    ctx.strokeStyle = "rgba(11,15,20,.35)";
    ctx.lineWidth = 4;
    ctx.strokeText(text, midX + 10, midY - 10);
    ctx.fillText(text, midX + 10, midY - 10);
    ctx.restore();
  }

  function redraw() {
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0, 0, rect.width, rect.height);

    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(245,245,247,.95)";
    ctx.fillStyle = "rgba(245,245,247,.95)";

    if (appMode === "calibrate") {
      if (calTaps.length >= 2) {
        ctx.beginPath();
        ctx.moveTo(calTaps[0].x, calTaps[0].y);
        ctx.lineTo(calTaps[1].x, calTaps[1].y);
        ctx.stroke();
      }
      calTaps.forEach((p, i) => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
        ctx.fillText(String(i + 1), p.x + 10, p.y - 10);
      });
      return;
    }

    if (appMode === "measure" && measureMode === "distance" && anchorA) {
      const b = lockedB || liveB || (targetMode === "crosshair" ? getCrosshairPoint() : null);
      if (!b) return;

      ctx.save();
      ctx.setLineDash([10, 8]);
      ctx.beginPath();
      ctx.moveTo(anchorA.x, anchorA.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
      ctx.restore();

      ctx.beginPath();
      ctx.arc(anchorA.x, anchorA.y, 6, 0, Math.PI * 2);
      ctx.fill();

      if (cmPerPx) {
        const cm = distPx(anchorA, b) * cmPerPx;
        drawLabelOnLine(anchorA, b, formatDistance(cm));
      }
      return;
    }

    if (appMode === "measure" && measureMode === "area") {
      if (areaTaps.length >= 2) {
        ctx.beginPath();
        ctx.moveTo(areaTaps[0].x, areaTaps[0].y);
        ctx.lineTo(areaTaps[1].x, areaTaps[1].y);
        ctx.stroke();
      }
      if (areaTaps.length >= 4) {
        ctx.beginPath();
        ctx.moveTo(areaTaps[2].x, areaTaps[2].y);
        ctx.lineTo(areaTaps[3].x, areaTaps[3].y);
        ctx.stroke();
      }
      areaTaps.forEach((p, i) => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
        ctx.fillText(String(i + 1), p.x + 10, p.y - 10);
      });
    }
  }

  function handleTap(pt) {
    if (!stream) { setResult("Avvia fotocamera", "—"); return; }

    if (appMode === "calibrate") {
      calTaps.push(pt);

      if (calTaps.length === 1) {
        setResult("Calibrazione", "Tocca il secondo punto");
        redraw();
        return;
      }

      if (calTaps.length === 2) {
        const refCm = getReferenceCm();
        if (!refCm) {
          calTaps = [];
          setResult("Calibrazione", "Valore cm non valido");
          redraw();
          return;
        }
        const px = distPx(calTaps[0], calTaps[1]);
        if (!(px > 0)) {
          calTaps = [];
          setResult("Calibrazione", "Distanza non valida");
          redraw();
          return;
        }
        cmPerPx = refCm / px;
        saveCalibration();
        setStatus();
        setModePill();
        setResult("Calibrato ✅", `Rapporto: ${cmPerPx.toExponential(3)} cm/px`);
        calTaps = [];
        redraw();
        return;
      }

      calTaps = [];
      redraw();
      return;
    }

    if (!cmPerPx) {
      setResult("Calibrazione richiesta", "Passa a Calibrazione e calibra prima");
      return;
    }

    if (measureMode === "distance") {
      if (!anchorA) {
        anchorA = pt;
        lockedB = null;
        liveB = (targetMode === "crosshair") ? getCrosshairPoint() : pt;
        setResult("Distanza (live)", "—");
        redraw();
        return;
      }

      if (anchorA && !lockedB) {
        lockedB = (targetMode === "crosshair") ? getCrosshairPoint() : (liveB || pt);
        isDragging = false;

        const cm = distPx(anchorA, lockedB) * cmPerPx;
        const text = `${formatDistance(cm)} (indicativa)`;
        setResult("Distanza", text);
        addToHistory(`Distanza: ${text}`);
        redraw();
        return;
      }

      anchorA = pt;
      lockedB = null;
      liveB = (targetMode === "crosshair") ? getCrosshairPoint() : pt;
      setResult("Distanza (live)", "—");
      redraw();
      return;
    }

    if (measureMode === "area") {
      areaTaps.push(pt);

      if (areaTaps.length === 1) {
        setResult("Area", "Tocca il secondo punto per la larghezza");
        redraw();
        return;
      }
      if (areaTaps.length === 2) {
        const cmW = distPx(areaTaps[0], areaTaps[1]) * cmPerPx;
        setResult("Area", `Larghezza: ${formatDistance(cmW)} — Ora 2 tap per altezza`);
        redraw();
        return;
      }
      if (areaTaps.length === 3) {
        setResult("Area", "Tocca il secondo punto per l’altezza");
        redraw();
        return;
      }
      if (areaTaps.length === 4) {
        const cmW = distPx(areaTaps[0], areaTaps[1]) * cmPerPx;
        const cmH = distPx(areaTaps[2], areaTaps[3]) * cmPerPx;
        const areaText = `${formatAreaMq(cmW * cmH)} (indicativa)`;
        setResult("Area (rettangolo)", areaText);
        addToHistory(`Area: ${areaText}`);
        areaTaps = [];
        redraw();
        return;
      }

      areaTaps = [];
      redraw();
      return;
    }
  }

  function handlePointerMove(evt) {
    if (appMode !== "measure") return;
    if (measureMode !== "distance") return;
    if (targetMode !== "finger") return;
    if (!anchorA) return;
    if (lockedB) return;
    if (!isDragging) return;

    const pt = canvasPointFromEvent(evt);
    liveB = pt;

    const cm = distPx(anchorA, liveB) * cmPerPx;
    setResult("Distanza (live)", `${formatDistance(cm)} (indicativa)`);
    redraw();
  }

  function handlePointerDown(evt) {
    if (appMode !== "measure") return;
    if (measureMode !== "distance") return;
    if (targetMode !== "finger") return;
    if (!anchorA) return;
    if (lockedB) return;

    isDragging = true;
    liveB = canvasPointFromEvent(evt);
    redraw();
  }

  function handlePointerUp(evt) {
    evt.preventDefault();

    if (appMode === "measure" && measureMode === "distance" && targetMode === "finger" && isDragging) {
      isDragging = false;
    }

    handleTap(canvasPointFromEvent(evt));
  }

  function wireUI() {
    document.getElementById("btnStartCam").addEventListener("click", startCamera);
    document.getElementById("btnStopCam").addEventListener("click", stopCamera);
    document.getElementById("btnFullscreen").addEventListener("click", enterFullscreen);

    document.getElementById("btnModeCal").addEventListener("click", () => enterCalibrationMode());

    document.getElementById("btnResetCal").addEventListener("click", () => {
      clearCalibration();
      setStatus();
      setModePill();
      setResult("Reset calibrazione", "—");
      redraw();
    });

    elRefPreset.addEventListener("change", () => {
      elRefCustom.style.display = (elRefPreset.value === "custom") ? "inline-block" : "none";
    });

    elMeasureMode.addEventListener("change", () => {
      measureMode = elMeasureMode.value;
      enterMeasureMode();  // chiude calibrazione e la disabilita (A)
      clearMeasureState();
      setModePill();
      updatePanelsState();

      if (measureMode === "distance") setResult("Distanza", "Tap A, trascina e tap finale");
      else setResult("Area", "2 tap larghezza + 2 tap altezza");
      redraw();
    });

    elTargetMode.addEventListener("change", () => {
      targetMode = elTargetMode.value;
      updatePanelsState();
      clearMeasureState();
      setResult("Distanza", targetMode === "finger" ? "Tap A, trascina e tap finale" : "Tap A, muovi e tap finale");
      redraw();
    });

    document.getElementById("btnClearMeasure").addEventListener("click", () => {
      clearMeasureState();
      setResult("—", "—");
      redraw();
    });

    document.getElementById("btnClearHistory").addEventListener("click", () => {
      history = [];
      updateHistoryUI();
    });

    elMsrPanel.addEventListener("toggle", () => {
      if (elMsrPanel.open && appMode !== "measure") enterMeasureMode();
    });

    canvas.addEventListener("pointerdown", (evt) => {
      evt.preventDefault();
      handlePointerDown(evt);
    });
    canvas.addEventListener("pointermove", (evt) => {
      evt.preventDefault();
      handlePointerMove(evt);
    });
    canvas.addEventListener("pointerup", handlePointerUp);

    window.addEventListener("resize", () => {
      resizeCanvasToDisplay();
      redraw();
    });

    document.addEventListener("fullscreenchange", () => {
      resizeCanvasToDisplay();
      redraw();
    });
  }

  function enterCalibrationMode() {
    appMode = "calibrate";
    clearMeasureState();
    calTaps = [];
    areaTaps = [];
    setResult("Calibrazione", "2 tap sul riferimento");
    setModePill();
    updatePanelsState();
    redraw();
  }

  function enterMeasureMode() {
    appMode = "measure";
    calTaps = [];
    setModePill();
    updatePanelsState();
    redraw();
  }

  function clearMeasureState() {
    anchorA = null;
    liveB = null;
    lockedB = null;
    isDragging = false;
    areaTaps = [];
  }

  function init() {
    video = document.getElementById("video");
    canvas = document.getElementById("overlay");
    ctx = canvas.getContext("2d");
    viewer = document.getElementById("viewer");
    crosshairEl = document.getElementById("crosshair");

    elStatusBadge = document.getElementById("statusBadge");
    elZoomBadge = document.getElementById("zoomBadge");
    elModePill = document.getElementById("modePill");
    elResultMain = document.getElementById("resultMain");
    elResultDetails = document.getElementById("resultDetails");

    elCalPanel = document.getElementById("calPanel");
    elMsrPanel = document.getElementById("msrPanel");
    elCalTag = document.getElementById("calTag");
    elMsrTag = document.getElementById("msrTag");

    elRefPreset = document.getElementById("refPreset");
    elRefCustom = document.getElementById("refCustom");

    elMeasureMode = document.getElementById("mode");
    elTargetMode = document.getElementById("targetMode");

    elHistoryList = document.getElementById("historyList");
    elHistoryMeta = document.getElementById("historyMeta");

    loadCalibration();
    setStatus();
    updateHistoryUI();
    updateZoomBadge();

    // default: measure distance, finger
    appMode = "measure";
    measureMode = "distance";
    targetMode = "finger";
    elMeasureMode.value = "distance";
    elTargetMode.value = "finger";
    setModePill();

    updatePanelsState();
    setResult("—", "Avvia fotocamera");

    requestAnimationFrame(() => {
      resizeCanvasToDisplay();
      redraw();
    });

    wireUI();

    const logo = document.getElementById("brandLogo");
    if (logo && !logo.getAttribute("src")) logo.style.display = "none";
  }

  return { init };
})();

document.addEventListener("DOMContentLoaded", () => {
  FRColorMeasureModule.init();
});
</script>
</body>
</html>
