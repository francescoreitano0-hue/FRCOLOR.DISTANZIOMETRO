/* ========= AR MODULE (WebXR reale: tap A/B + laser live + save) ========= */
(() => {
  const arVideo = document.getElementById('arVideo');
  const arGL    = document.getElementById('arGL');
  const arHud   = document.getElementById('arHud');

  const btnCam  = document.getElementById('arStartCam');
  const btnTry  = document.getElementById('arTryWebXR');
  const btnReset= document.getElementById('arReset');
  const btnSave = document.getElementById('arSave');
  const btnClear= document.getElementById('arClearHistory');

  const pillAR  = document.getElementById('arPill');
  const pillMode= document.getElementById('arModePill');
  const modeSel = document.getElementById('arModeSel');

  const outMain = document.getElementById('arOutMain');
  const outSub  = document.getElementById('arOutSub');

  const histLbl = document.getElementById('arHistLabel');
  const histList= document.getElementById('arHistList');

  const S = {
    session: null,
    gl: null,
    refSpace: null,
    viewerSpace: null,
    hitTestSource: null,

    mode: 'distance',     // distance | area
    points: [],           // stored points in refSpace: {x,y,z}
    lastHit: null,        // reticle point live
    lastValueText: null,

    history: []
  };

  function setPill(el, text, kind){
    el.textContent = text;
    el.classList.remove('ok','warn','bad');
    if(kind) el.classList.add(kind);
  }
  function setResult(m,s){ outMain.textContent=m; outSub.textContent=s||''; }

  function fmtMeters(m){
    if (!Number.isFinite(m)) return '—';
    if (m >= 10) return `${m.toFixed(2)} m`;
    if (m >= 1)  return `${m.toFixed(3)} m`;
    return `${(m*100).toFixed(1)} cm`;
  }
  function fmtArea(m2){
    if (!Number.isFinite(m2)) return '—';
    return `${m2.toFixed(2)} m²`;
  }

  function dist(a,b){
    const dx=a.x-b.x, dy=a.y-b.y, dz=a.z-b.z;
    return Math.sqrt(dx*dx+dy*dy+dz*dz);
  }
  function areaRect(p1,p2,p3,p4){
    const w = dist(p1,p2);
    const h = dist(p3,p4);
    return w*h;
  }

  function updateHistory(){
    histList.innerHTML='';
    S.history.forEach(x => { const li=document.createElement('li'); li.textContent=x; histList.appendChild(li); });
    histLbl.textContent = `Storico misure (${S.history.length}/10)`;
  }
  function addHistory(x){
    if (S.history.length === 10) S.history = []; // reset alla 11ª
    S.history.push(x);
    updateHistory();
  }

  function resetMeasure(){
    S.points = [];
    S.lastValueText = null;
    btnSave.disabled = true;
    btnReset.disabled = false;

    setResult('—',
      S.mode === 'distance'
        ? 'AR attivo. Tap 1 = punto A. Muovi: laser + valore live. Tap 2 = punto B.'
        : 'AR attivo. Area: 4 tap (rettangolo). Dopo il 4° tap puoi salvare.'
    );
  }

  // ---- Overlay 2D ----
  function resizeHud(){
    const dpr = window.devicePixelRatio || 1;
    const rect = arHud.getBoundingClientRect();
    arHud.width = Math.max(1, Math.round(rect.width * dpr));
    arHud.height= Math.max(1, Math.round(rect.height * dpr));
  }
  window.addEventListener('resize', resizeHud);

  // minimal mat4 utils for projection
  function mat4Invert(a){
    const inv = new Float32Array(16);
    inv[0]=a[5]*a[10]*a[15]-a[5]*a[11]*a[14]-a[9]*a[6]*a[15]+a[9]*a[7]*a[14]+a[13]*a[6]*a[11]-a[13]*a[7]*a[10];
    inv[4]=-a[4]*a[10]*a[15]+a[4]*a[11]*a[14]+a[8]*a[6]*a[15]-a[8]*a[7]*a[14]-a[12]*a[6]*a[11]+a[12]*a[7]*a[10];
    inv[8]=a[4]*a[9]*a[15]-a[4]*a[11]*a[13]-a[8]*a[5]*a[15]+a[8]*a[7]*a[13]+a[12]*a[5]*a[11]-a[12]*a[7]*a[9];
    inv[12]=-a[4]*a[9]*a[14]+a[4]*a[10]*a[13]+a[8]*a[5]*a[14]-a[8]*a[6]*a[13]-a[12]*a[5]*a[10]+a[12]*a[6]*a[9];
    inv[1]=-a[1]*a[10]*a[15]+a[1]*a[11]*a[14]+a[9]*a[2]*a[15]-a[9]*a[3]*a[14]-a[13]*a[2]*a[11]+a[13]*a[3]*a[10];
    inv[5]=a[0]*a[10]*a[15]-a[0]*a[11]*a[14]-a[8]*a[2]*a[15]+a[8]*a[3]*a[14]+a[12]*a[2]*a[11]-a[12]*a[3]*a[10];
    inv[9]=-a[0]*a[9]*a[15]+a[0]*a[11]*a[13]+a[8]*a[1]*a[15]-a[8]*a[3]*a[13]-a[12]*a[1]*a[11]+a[12]*a[3]*a[9];
    inv[13]=a[0]*a[9]*a[14]-a[0]*a[10]*a[13]-a[8]*a[1]*a[14]+a[8]*a[2]*a[13]+a[12]*a[1]*a[10]-a[12]*a[2]*a[9];
    inv[2]=a[1]*a[6]*a[15]-a[1]*a[7]*a[14]-a[5]*a[2]*a[15]+a[5]*a[3]*a[14]+a[13]*a[2]*a[7]-a[13]*a[3]*a[6];
    inv[6]=-a[0]*a[6]*a[15]+a[0]*a[7]*a[14]+a[4]*a[2]*a[15]-a[4]*a[3]*a[14]-a[12]*a[2]*a[7]+a[12]*a[3]*a[6];
    inv[10]=a[0]*a[5]*a[15]-a[0]*a[7]*a[13]-a[4]*a[1]*a[15]+a[4]*a[3]*a[13]+a[12]*a[1]*a[7]-a[12]*a[3]*a[5];
    inv[14]=-a[0]*a[5]*a[14]+a[0]*a[6]*a[13]+a[4]*a[1]*a[14]-a[4]*a[2]*a[13]-a[12]*a[1]*a[6]+a[12]*a[2]*a[5];
    inv[3]=-a[1]*a[6]*a[11]+a[1]*a[7]*a[10]+a[5]*a[2]*a[11]-a[5]*a[3]*a[10]-a[9]*a[2]*a[7]+a[9]*a[3]*a[6];
    inv[7]=a[0]*a[6]*a[11]-a[0]*a[7]*a[10]-a[4]*a[2]*a[11]+a[4]*a[3]*a[10]+a[8]*a[2]*a[7]-a[8]*a[3]*a[6];
    inv[11]=-a[0]*a[5]*a[11]+a[0]*a[7]*a[9]+a[4]*a[1]*a[11]-a[4]*a[3]*a[9]-a[8]*a[1]*a[7]+a[8]*a[3]*a[5];
    inv[15]=a[0]*a[5]*a[10]-a[0]*a[6]*a[9]-a[4]*a[1]*a[10]+a[4]*a[2]*a[9]+a[8]*a[1]*a[6]-a[8]*a[2]*a[5];
    let det=a[0]*inv[0]+a[1]*inv[4]+a[2]*inv[8]+a[3]*inv[12];
    if(!det) return null;
    det=1.0/det;
    for(let i=0;i<16;i++) inv[i]*=det;
    return inv;
  }
  function mat4Mul(a,b){
    const o=new Float32Array(16);
    for(let i=0;i<4;i++){
      for(let j=0;j<4;j++){
        o[j+i*4]=a[i*4+0]*b[j+0]+a[i*4+1]*b[j+4]+a[i*4+2]*b[j+8]+a[i*4+3]*b[j+12];
      }
    }
    return o;
  }
  function projectPoint(pt, view){
    const proj=view.projectionMatrix;
    const camM=view.transform.matrix;
    const viewM=mat4Invert(camM);
    if(!viewM) return null;
    const vp=mat4Mul(proj, viewM);

    const x=pt.x,y=pt.y,z=pt.z;
    const clipX=vp[0]*x+vp[4]*y+vp[8]*z+vp[12];
    const clipY=vp[1]*x+vp[5]*y+vp[9]*z+vp[13];
    const clipW=vp[3]*x+vp[7]*y+vp[11]*z+vp[15];
    if(!clipW) return null;

    const ndcX=clipX/clipW, ndcY=clipY/clipW;
    return {
      x:(ndcX*0.5+0.5)*arHud.width,
      y:(-ndcY*0.5+0.5)*arHud.height
    };
  }

  function drawOverlay(view){
    const ctx = arHud.getContext('2d');
    ctx.clearRect(0,0,arHud.width,arHud.height);

    // crosshair
    const cx=arHud.width/2, cy=arHud.height/2;
    ctx.strokeStyle='rgba(245,245,247,.92)';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(cx-18,cy); ctx.lineTo(cx+18,cy);
    ctx.moveTo(cx,cy-18); ctx.lineTo(cx,cy+18);
    ctx.stroke();

    if(!view) return;

    // distance laser
    if(S.mode==='distance' && S.points.length>=1){
      const A = S.points[0];
      const B = (S.points.length>=2) ? S.points[1] : S.lastHit;
      if(B){
        const pA=projectPoint(A,view), pB=projectPoint(B,view);
        if(pA && pB){
          ctx.save();
          ctx.setLineDash([18,12]);
          ctx.strokeStyle='rgba(245,245,247,.95)';
          ctx.lineWidth=3;
          ctx.beginPath(); ctx.moveTo(pA.x,pA.y); ctx.lineTo(pB.x,pB.y); ctx.stroke();

          if(S.lastValueText){
            const midX=(pA.x+pB.x)/2, midY=(pA.y+pB.y)/2;
            ctx.setLineDash([]);
            ctx.font=`${Math.round(14*(window.devicePixelRatio||1))}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace`;
            ctx.lineWidth=6;
            ctx.strokeStyle='rgba(11,15,20,.35)';
            ctx.fillStyle='rgba(245,245,247,.95)';
            ctx.strokeText(S.lastValueText, midX+18, midY-18);
            ctx.fillText(S.lastValueText, midX+18, midY-18);
          }
          ctx.restore();
        }
      }
    }

    // area segments (simple)
    if(S.mode==='area' && S.points.length>0){
      ctx.save();
      ctx.strokeStyle='rgba(245,245,247,.95)';
      ctx.lineWidth=3;
      ctx.setLineDash([14,10]);

      for(let i=0;i<S.points.length-1;i++){
        const p1=projectPoint(S.points[i],view);
        const p2=projectPoint(S.points[i+1],view);
        if(p1 && p2){
          ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
        }
      }
      if(S.points.length<4 && S.lastHit){
        const p1=projectPoint(S.points[S.points.length-1],view);
        const p2=projectPoint(S.lastHit,view);
        if(p1 && p2){
          ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
        }
      }
      ctx.restore();
    }
  }

  function hideVideoShowXR(){
    arVideo.style.display = 'none';
    arGL.style.display = 'block';
  }
  function showVideoHideXR(){
    arVideo.style.display = 'block';
    arGL.style.display = 'none';
  }

  function resizeGL(){
    const dpr = window.devicePixelRatio || 1;
    const rect = arGL.getBoundingClientRect();
    arGL.width  = Math.max(1, Math.round(rect.width * dpr));
    arGL.height = Math.max(1, Math.round(rect.height * dpr));
  }

  async function startWebXR(){
    const ok = await checkWebXRAR();
    if(!ok){
      setPill(pillAR,'AR: non supportato','warn');
      setResult('AR non disponibile','Questo dispositivo/browser non supporta WebXR AR. Usa Telemetro.');
      return;
    }

    // Stop camera stream visual (se attivo) e passa a XR
    showVideoHideXR(); // prima mostra per sicurezza
    hideVideoShowXR();
    resizeGL();
    resizeHud();

    const gl = arGL.getContext('webgl', { alpha:true, antialias:true });
    if(!gl){
      setPill(pillAR,'AR: WebGL KO','bad');
      setResult('Errore','WebGL non disponibile.');
      showVideoHideXR();
      return;
    }

    S.gl = gl;

    let session;
    try{
      session = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['hit-test'],
        optionalFeatures: ['local-floor', 'dom-overlay'],
        domOverlay: { root: document.body }
      });
    }catch(e){
      setPill(pillAR,'AR: avvio KO','bad');
      setResult('Errore avvio AR','Richiesta sessione AR rifiutata.');
      showVideoHideXR();
      return;
    }

    S.session = session;
    setPill(pillAR,'AR: attivo','ok');
    btnReset.disabled = false;

    session.addEventListener('end', () => {
      S.session=null; S.hitTestSource=null; S.refSpace=null; S.viewerSpace=null;
      setPill(pillAR,'AR: fermo','warn');
      setResult('—','Sessione AR terminata.');
      btnSave.disabled = true;
      btnReset.disabled = true;
      showVideoHideXR(); // torna alla camera normale
    });

    const layer = new XRWebGLLayer(session, gl);
    session.updateRenderState({ baseLayer: layer });

    S.refSpace = await session.requestReferenceSpace('local-floor').catch(async() => session.requestReferenceSpace('local'));
    S.viewerSpace = await session.requestReferenceSpace('viewer');
    S.hitTestSource = await session.requestHitTestSource({ space: S.viewerSpace });

    // Tap = select
    session.addEventListener('select', () => {
      if(!S.lastHit) return;

      if(S.mode==='distance'){
        if(S.points.length===0){
          S.points=[S.lastHit];
          btnSave.disabled = true;
          setResult('Distanza (live)','Punto A impostato. Muovi: valore live. Tap per fissare B.');
        }else if(S.points.length===1){
          S.points=[S.points[0], S.lastHit];
          btnSave.disabled = false;
          setResult('Distanza pronta', S.lastValueText || '—');
        }else{
          // riparti
          S.points=[S.lastHit];
          btnSave.disabled = true;
          setResult('Distanza (live)','Nuovo A impostato. Tap per fissare B.');
        }
      }else{
        // area: 4 taps
        if(S.points.length<4){
          S.points.push(S.lastHit);
          if(S.points.length===4){
            btnSave.disabled = false;
            setResult('Area pronta', S.lastValueText || '—');
          }else{
            btnSave.disabled = true;
            setResult('Area', `Punti: ${S.points.length}/4 (tap per aggiungere)`);
          }
        }else{
          S.points=[S.lastHit];
          btnSave.disabled = true;
          setResult('Area','Riparti: punti 1/4');
        }
      }
    });

    resetMeasure();
    session.requestAnimationFrame(onXRFrame);
  }

  function onXRFrame(t, frame){
    const session = frame.session;
    const gl = S.gl;
    const layer = session.renderState.baseLayer;

    session.requestAnimationFrame(onXRFrame);

    const pose = frame.getViewerPose(S.refSpace);
    if(!pose) return;

    const view = pose.views[0];
    const viewport = layer.getViewport(view);

    gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // hit-test al centro (mirino)
    const hits = frame.getHitTestResults(S.hitTestSource);
    if(hits.length){
      const hitPose = hits[0].getPose(S.refSpace);
      if(hitPose){
        const p = hitPose.transform.position;
        S.lastHit = { x:p.x, y:p.y, z:p.z };
      }
    }

    // valore live
    if(S.mode==='distance' && S.points.length>=1 && S.lastHit){
      const A=S.points[0];
      const B=(S.points.length>=2) ? S.points[1] : S.lastHit;
      const m=dist(A,B);
      S.lastValueText = fmtMeters(m);
      if(S.points.length<2){
        setResult('Distanza (live)', `${S.lastValueText} • tap per fissare B`);
      }
    }

    if(S.mode==='area'){
      if(S.points.length===4){
        const a=areaRect(S.points[0],S.points[1],S.points[2],S.points[3]);
        S.lastValueText = fmtArea(a);
      }else if(S.points.length>=2){
        const w=dist(S.points[0], S.points[1]);
        S.lastValueText = `Larghezza: ${fmtMeters(w)}`;
      }else{
        S.lastValueText = null;
      }
    }

    drawOverlay(view);
  }

  // ---- UI wiring ----
  btnCam.addEventListener('click', async () => {
    try{
      await startCamera(arVideo);
      setPill(pillAR,'AR: camera OK','ok');
      setResult('—','Camera attiva (mirino). Ora premi “Prova AR (WebXR)”.');
      showVideoHideXR(); // in camera view
      resizeHud();
    }catch(err){
      setPill(pillAR,'AR: camera KO','bad');
      setResult('Errore camera', err.message);
    }
  });

  btnTry.addEventListener('click', startWebXR);

  btnReset.addEventListener('click', () => {
    resetMeasure();
  });

  btnSave.addEventListener('click', () => {
    if(S.mode==='distance' && S.points.length>=2){
      const m = dist(S.points[0], S.points[1]);
      addHistory(`AR Distanza: ${fmtMeters(m)}`);
      btnSave.disabled = true;
      setResult('Salvato ✅', `AR Distanza: ${fmtMeters(m)}`);
    }
    if(S.mode==='area' && S.points.length===4){
      const a = areaRect(S.points[0],S.points[1],S.points[2],S.points[3]);
      addHistory(`AR Area: ${fmtArea(a)}`);
      btnSave.disabled = true;
      setResult('Salvato ✅', `AR Area: ${fmtArea(a)}`);
    }
  });

  btnClear.addEventListener('click', () => { S.history=[]; updateHistory(); });

  modeSel.addEventListener('change', () => {
    S.mode = modeSel.value;
    pillMode.textContent = `Modalità: ${S.mode==='distance' ? 'Distanza' : 'Area'}`;
    resetMeasure();
  });

  // init
  showVideoHideXR();
  arGL.style.display = 'none';
  setPill(pillAR,'AR: —','warn');
  pillMode.textContent = 'Modalità: Distanza';
  updateHistory();
  resizeHud();
})();
