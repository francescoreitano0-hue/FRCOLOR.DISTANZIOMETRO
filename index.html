
<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FR Color — Misurazione (Compatibile)</title>

  <style>
    /* =========================================================
       FR COLOR — UI THEME (UFFICIALE)
       Palette ufficiale:
       Navy: #1D3557
       Light gray: #F5F5F7
       Accenti (solo quando serve):
       Teal #26A69A, Blue #1E88E5, Red #E53935, Orange #FB8C00,
       Yellow #FDD835, Green #43A047, Purple #8E24AA
       Stile: pulito, tecnico, ordinato, medio–alto
       ========================================================= */
    :root{
      --bg: #F5F5F7;
      --surface: #FFFFFF;
      --text: #1D3557;
      --muted: rgba(29,53,87,.72);
      --border: rgba(29,53,87,.14);
      --shadow: 0 8px 24px rgba(29,53,87,.08);

      --primary: #1D3557;
      --ok: #26A69A;
      --ok-weak: rgba(38,166,154,.16);
      --warn: #FB8C00;
      --warn-weak: rgba(251,140,0,.16);
      --bad: #E53935;
      --bad-weak: rgba(229,57,53,.14);

      --radius: 16px;
      --radius-sm: 12px;
    }

    *{box-sizing:border-box}
    html, body{height:100%}
    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 14px;
    }

    .brandbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 14px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--surface);
      box-shadow: var(--shadow);
      flex-wrap:wrap;
    }
    .brandleft{
      display:flex;
      align-items:center;
      gap:12px;
      min-width:0;
    }
    .brandlogo{
      width: 120px;
      max-width: 38vw;
      height:auto;
      display:block;
    }
    .brandtitle{min-width:0}
    .brandtitle .title{
      margin: 0;
      font-weight: 800;
      letter-spacing: .2px;
      font-size: 15px;
      line-height: 1.1;
    }
    .brandtitle .sub{
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
      line-height: 1.35;
    }

    .status{
      font-size:12px;
      padding:7px 12px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      background:#fff;
      white-space:nowrap;
    }
    .status.ok{
      color:var(--ok);
      border-color: rgba(38,166,154,.35);
      background: var(--ok-weak);
    }
    .status.warn{
      color:var(--warn);
      border-color: rgba(251,140,0,.35);
      background: var(--warn-weak);
    }

    .grid{
      margin-top:12px;
      display:grid;
      gap:12px;
      grid-template-columns: 1.2fr .8fr;
    }
    @media (max-width: 900px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow:hidden;
      background: var(--surface);
      box-shadow: var(--shadow);
    }
    .card h3{
      margin:0;
      padding: 12px 14px 10px;
      font-size: 13px;
      font-weight: 800;
      letter-spacing: .2px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, #ffffff, rgba(29,53,87,.02));
    }
    .card .body{padding:14px;}

    /* ===============================
       VIEWER (camera) — DESKTOP
       =============================== */
    .viewer{
      position:relative;
      width:100%;
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
      background:#0b0f14;
      aspect-ratio: 16/10;
    }
    video{width:100%; height:100%; object-fit:cover; display:block}
    canvas{position:absolute; inset:0; width:100%; height:100%; touch-action:none}

    /* ===============================
       VIEWER — MOBILE (60vh)
       =============================== */
    @media (max-width: 900px){
      .viewer{
        aspect-ratio: auto;
        height: min(60vh, 520px);
        min-height: 360px;
      }
      video, canvas{height:100%;}
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .btn{
      appearance:none;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      padding: 10px 12px;
      border-radius: var(--radius-sm);
      font-weight: 800;
      cursor: pointer;
      transition: transform .04s ease, background .12s ease, border-color .12s ease;
    }
    .btn:active{transform:translateY(1px)}
    .btn.primary{
      background: var(--primary);
      border-color: var(--primary);
      color: #fff;
    }
    .btn.primary:hover{background:#16304d}
    .btn:hover{background: rgba(29,53,87,.04)}
    .btn.small{padding:8px 10px; font-size:12px}
    .btn.danger{
      background:#fff;
      color: var(--bad);
      border-color: rgba(229,57,53,.35);
    }
    .btn.danger:hover{background: var(--bad-weak)}

    .select, .input{
      border:1px solid var(--border);
      background:#fff;
      color: var(--text);
      padding:10px 12px;
      border-radius: var(--radius-sm);
      outline:none;
      min-width: 180px;
      font-weight:700;
    }
    .select:focus, .input:focus{
      border-color: rgba(30,136,229,.45);
      box-shadow: 0 0 0 4px rgba(30,136,229,.14);
    }

    .hint{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
      margin: 8px 0 0;
    }

    .sep{height:1px; background: var(--border); margin: 12px 0}

    .pill{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      color: var(--muted);
      background:#fff;
      font-weight:800;
    }
    .pill.ok{
      color:var(--ok);
      border-color: rgba(38,166,154,.35);
      background: var(--ok-weak);
    }
    .pill.bad{
      color:var(--bad);
      border-color: rgba(229,57,53,.35);
      background: var(--bad-weak);
    }

    .result{
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: #fff;
    }
    .result .label{
      font-size:12px;
      color: var(--muted);
      font-weight:800;
      letter-spacing:.15px;
    }
    .result strong{
      display:block;
      font-size: 17px;
      margin-top:4px;
      letter-spacing:.2px;
    }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}

    /* Fullscreen: lascia che la camera occupi lo schermo */
    .viewer:fullscreen{
      width:100vw;
      height:100vh;
      border-radius:0;
      border:0;
    }
    .viewer:-webkit-full-screen{
      width:100vw;
      height:100vh;
      border-radius:0;
      border:0;
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="brandbar">
      <div class="brandleft">
        <!-- Inserisci qui il logo ufficiale FR Color (PNG trasparente) -->
        <!-- Esempio: src="assets/frcolor-logo.png" -->
        <img class="brandlogo" id="brandLogo" src="" alt="FR Color — Logo ufficiale" />
        <div class="brandtitle">
          <p class="title">Misurazione (Modalità Compatibile)</p>
          <div class="sub">
            Fotocamera + calibrazione manuale. Indicativo: interni “pochi cm”, esterni 20–30 m stima.
          </div>
        </div>
      </div>
      <div id="statusBadge" class="status warn">Calibrazione: NON attiva</div>
    </div>

    <div class="grid">
      <div class="card">
        <h3>Anteprima</h3>
        <div class="body">
          <div class="viewer" id="viewer">
            <video id="video" playsinline muted></video>
            <canvas id="overlay"></canvas>
          </div>

          <div class="sep"></div>

          <div class="row">
            <button id="btnStartCam" class="btn primary">Avvia fotocamera</button>
            <button id="btnStopCam" class="btn">Ferma</button>
            <button id="btnFullscreen" class="btn">Schermo intero</button>
            <span id="modePill" class="pill">Modalità: —</span>
          </div>

          <p class="hint">
            Regola: se cambi zoom/lente o condizioni, rifai calibrazione. Evita lo zoom per misure più affidabili.
          </p>
        </div>
      </div>

      <div class="card">
        <h3>Controlli</h3>
        <div class="body">

          <div class="row">
            <select id="mode" class="select">
              <option value="calibrate">Calibrazione</option>
              <option value="distance">Misura distanza</option>
              <option value="area">Misura area (rettangolo)</option>
            </select>

            <select id="refPreset" class="select">
              <option value="21">A4 lato corto (21 cm)</option>
              <option value="29.7">A4 lato lungo (29.7 cm)</option>
              <option value="8.56">Carta di credito (8.56 cm)</option>
              <option value="custom">Valore manuale…</option>
            </select>

            <input id="refCustom" class="input" type="number" step="0.1" min="0" placeholder="cm (manuale)" style="display:none" />
          </div>

          <div class="sep"></div>

          <div class="row">
            <button id="btnRecalibrate" class="btn small">Rifai calibrazione</button>
            <button id="btnReset" class="btn small danger">Reset</button>
          </div>

          <div class="sep"></div>

          <div class="result">
            <div class="label">Risultato</div>
            <strong id="resultMain">—</strong>
            <div class="hint mono" id="resultDetails">Tocca i punti sul video per operare.</div>
          </div>

          <div class="sep"></div>

          <p class="hint">
            <span class="mono">Calibrazione</span>: tocca 2 punti sul riferimento inquadrato (es. lato A4).
            Poi passa a <span class="mono">Misura distanza</span> o <span class="mono">Misura area</span>.
          </p>

        </div>
      </div>
    </div>
  </div>

<script>
/**
 * FRColorMeasureModule
 * - Modulo isolato: salva solo calibrazione in localStorage.
 * - Modalità:
 *   1) Calibrazione: 2 tap su riferimento (cm noti) => cmPerPx
 *   2) Distanza: 2 tap => distanza
 *   3) Area rettangolo: 2 tap larghezza + 2 tap altezza => mq
 * - Non dipende da WebXR/ARCore.
 */
const FRColorMeasureModule = (() => {
  const LS_KEY = "frcolor_measure_calibration_v1";

  let video, canvas, ctx, viewer;
  let stream = null;

  // state
  let mode = "calibrate"; // calibrate | distance | area
  let taps = [];          // points in CSS coords
  let cmPerPx = null;     // number
  let calibrationMeta = null;

  // UI
  let elStatusBadge, elMode, elModePill, elRefPreset, elRefCustom;
  let elResultMain, elResultDetails;

  function nowISO(){ return new Date().toISOString(); }

  function loadCalibration() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (typeof obj?.cmPerPx === "number" && obj.cmPerPx > 0) {
        cmPerPx = obj.cmPerPx;
        calibrationMeta = obj.meta || null;
      }
    } catch {}
  }

  function saveCalibration() {
    const payload = {
      cmPerPx,
      meta: {
        savedAt: nowISO(),
        videoSettings: stream?.getVideoTracks?.()?.[0]?.getSettings?.() || null,
        userAgent: navigator.userAgent
      }
    };
    localStorage.setItem(LS_KEY, JSON.stringify(payload));
    calibrationMeta = payload.meta;
  }

  function clearCalibration() {
    localStorage.removeItem(LS_KEY);
    cmPerPx = null;
    calibrationMeta = null;
  }

  function setStatus() {
    if (!elStatusBadge) return;
    if (cmPerPx) {
      elStatusBadge.className = "status ok";
      const when = calibrationMeta?.savedAt ? calibrationMeta.savedAt.split("T")[0] : "—";
      elStatusBadge.textContent = `Calibrazione: attiva (${when})`;
    } else {
      elStatusBadge.className = "status warn";
      elStatusBadge.textContent = "Calibrazione: NON attiva";
    }
  }

  function updateModePill() {
    const label = mode === "calibrate" ? "Calibrazione"
      : (mode === "distance" ? "Distanza" : "Area");
    elModePill.textContent = `Modalità: ${label}`;
    elModePill.className = "pill " + (cmPerPx ? "ok" : "bad");
  }

  function setResult(main, details) {
    elResultMain.textContent = main;
    elResultDetails.textContent = details;
  }

  function resetTaps() {
    taps = [];
    redraw();
  }

  function setMode(newMode) {
    mode = newMode;
    resetTaps();
    updateModePill();
    if (mode === "calibrate") {
      setResult("—", "Inquadra il riferimento e tocca 2 punti per calibrare.");
    } else if (mode === "distance") {
      setResult("—", "Tocca 2 punti per misurare la distanza.");
    } else {
      setResult("—", "Tocca 2 punti per larghezza, poi 2 punti per altezza.");
    }
  }

  async function startCamera() {
    if (!navigator.mediaDevices?.getUserMedia) {
      setResult("Errore", "Browser non supporta getUserMedia.");
      return;
    }
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: "environment" } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      resizeCanvasToDisplay();
      redraw();
      setResult("Camera OK", "Seleziona modalità e tocca i punti sul video.");
    } catch (e) {
      setResult("Camera non avviata", `${e.name || "Errore"}: ${e.message || ""}`.trim());
    }
  }

  function stopCamera() {
    try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch {}
    stream = null;
    video.srcObject = null;
    setResult("Camera fermata", "Riavvia fotocamera quando serve.");
  }

  function enterFullscreen() {
    const el = viewer;
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
    if (req) req.call(el);
  }

  function getReferenceCm() {
    const preset = elRefPreset.value;
    if (preset === "custom") {
      const v = parseFloat(elRefCustom.value);
      return (Number.isFinite(v) && v > 0) ? v : null;
    }
    const n = parseFloat(preset);
    return (Number.isFinite(n) && n > 0) ? n : null;
  }

  function resizeCanvasToDisplay() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.round(rect.width * dpr));
    canvas.height = Math.max(1, Math.round(rect.height * dpr));
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr); // disegniamo in coordinate CSS
  }

  function canvasPointFromEvent(evt) {
    const rect = canvas.getBoundingClientRect();
    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
  }

  function distPx(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function formatDistance(cm) {
    if (cm >= 100) return (cm/100).toFixed(2) + " m";
    return cm.toFixed(1) + " cm";
  }

  function formatAreaMq(cm2) {
    const mq = cm2 / 10000;
    return mq.toFixed(2) + " m²";
  }

  function handleTap(pt) {
    if (!stream) {
      setResult("Avvia la fotocamera", "Prima avvia la fotocamera, poi tocca i punti.");
      return;
    }

    taps.push(pt);

    // --- CALIBRAZIONE ---
    if (mode === "calibrate") {
      if (taps.length === 1) {
        setResult("Calibrazione", "Tocca il secondo punto sul riferimento.");
        redraw();
        return;
      }
      if (taps.length === 2) {
        const refCm = getReferenceCm();
        if (!refCm) {
          resetTaps();
          setResult("Calibrazione", "Inserisci un valore valido (cm) e riprova.");
          return;
        }
        const px = distPx(taps[0], taps[1]);
        if (!(px > 0)) {
          resetTaps();
          setResult("Calibrazione", "Distanza non valida. Riprova.");
          return;
        }
        cmPerPx = refCm / px;
        saveCalibration();
        setStatus();
        updateModePill();
        setResult("Calibrato ✅", `Rapporto: ${cmPerPx.toExponential(3)} cm/px — Puoi misurare.`);
        resetTaps();
        return;
      }
      resetTaps();
      return;
    }

    // per misure serve calibrazione
    if (!cmPerPx) {
      resetTaps();
      setResult("Calibrazione richiesta", "Prima calibra (Modalità Calibrazione).");
      return;
    }

    // --- DISTANZA ---
    if (mode === "distance") {
      if (taps.length === 1) {
        setResult("Distanza", "Tocca il secondo punto.");
        redraw();
        return;
      }
      if (taps.length === 2) {
        const cm = distPx(taps[0], taps[1]) * cmPerPx;
        setResult("Distanza", `${formatDistance(cm)} (indicativa)`);
        resetTaps();
        return;
      }
      resetTaps();
      return;
    }

    // --- AREA (rettangolo): 2 tap larghezza + 2 tap altezza ---
    if (mode === "area") {
      if (taps.length === 1) {
        setResult("Area", "Tocca il secondo punto per la larghezza.");
        redraw();
        return;
      }
      if (taps.length === 2) {
        const cmW = distPx(taps[0], taps[1]) * cmPerPx;
        setResult("Area", `Larghezza: ${formatDistance(cmW)} — Ora 2 tocchi per altezza.`);
        redraw();
        return;
      }
      if (taps.length === 3) {
        setResult("Area", "Tocca il secondo punto per l’altezza.");
        redraw();
        return;
      }
      if (taps.length === 4) {
        const cmW = distPx(taps[0], taps[1]) * cmPerPx;
        const cmH = distPx(taps[2], taps[3]) * cmPerPx;
        const cm2 = cmW * cmH;
        setResult("Area (rettangolo)", `${formatAreaMq(cm2)} (indicativa)`);
        resetTaps();
        return;
      }
      resetTaps();
      return;
    }
  }

  function redraw() {
    if (!ctx) return;
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0, 0, rect.width, rect.height);

    // overlay tecnico pulito (bianco)
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(245,245,247,.95)";
    ctx.fillStyle = "rgba(245,245,247,.95)";

    // linee
    if (taps.length >= 2) {
      // prima coppia
      ctx.beginPath();
      ctx.moveTo(taps[0].x, taps[0].y);
      ctx.lineTo(taps[1].x, taps[1].y);
      ctx.stroke();
    }
    if (mode === "area" && taps.length >= 4) {
      // seconda coppia (altezza)
      ctx.beginPath();
      ctx.moveTo(taps[2].x, taps[2].y);
      ctx.lineTo(taps[3].x, taps[3].y);
      ctx.stroke();
    }

    // punti
    taps.forEach((p, i) => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      ctx.fillText(String(i + 1), p.x + 10, p.y - 10);
    });
  }

  function wireUI() {
    document.getElementById("btnStartCam").addEventListener("click", startCamera);
    document.getElementById("btnStopCam").addEventListener("click", stopCamera);
    document.getElementById("btnFullscreen").addEventListener("click", enterFullscreen);

    elMode.addEventListener("change", () => setMode(elMode.value));

    elRefPreset.addEventListener("change", () => {
      elRefCustom.style.display = (elRefPreset.value === "custom") ? "inline-block" : "none";
    });

    document.getElementById("btnRecalibrate").addEventListener("click", () => {
      elMode.value = "calibrate";
      setMode("calibrate");
    });

    document.getElementById("btnReset").addEventListener("click", () => {
      clearCalibration();
      setStatus();
      updateModePill();
      resetTaps();
      setResult("Reset", "Calibrazione cancellata. Rifai calibrazione quando vuoi.");
    });

    canvas.addEventListener("pointerdown", (evt) => {
      evt.preventDefault();
      handleTap(canvasPointFromEvent(evt));
      redraw();
    });

    window.addEventListener("resize", () => {
      resizeCanvasToDisplay();
      redraw();
    });

    document.addEventListener("fullscreenchange", () => {
      // quando entra/esce fullscreen, ridimensiona overlay
      resizeCanvasToDisplay();
      redraw();
    });
  }

  function init() {
    video = document.getElementById("video");
    canvas = document.getElementById("overlay");
    ctx = canvas.getContext("2d");
    viewer = document.getElementById("viewer");

    elStatusBadge = document.getElementById("statusBadge");
    elMode = document.getElementById("mode");
    elModePill = document.getElementById("modePill");
    elRefPreset = document.getElementById("refPreset");
    elRefCustom = document.getElementById("refCustom");
    elResultMain = document.getElementById("resultMain");
    elResultDetails = document.getElementById("resultDetails");

    loadCalibration();
    setStatus();

    // default
    setMode("calibrate");
    elMode.value = "calibrate";

    requestAnimationFrame(() => {
      resizeCanvasToDisplay();
      redraw();
    });

    wireUI();

    // se logo non impostato, non rompe nulla
    const logo = document.getElementById("brandLogo");
    if (logo && !logo.getAttribute("src")) {
      logo.style.display = "none";
    }

    if (!cmPerPx) {
      setResult("Pronto", "Avvia fotocamera → calibra (2 tocchi) → misura.");
    } else {
      setResult("Pronto ✅", "Calibrazione presente. Puoi misurare o rifare calibrazione.");
    }
    updateModePill();
  }

  return { init };
})();

document.addEventListener("DOMContentLoaded", () => {
  FRColorMeasureModule.init();
});
</script>
</body>
</html>
